# Setup Mouth Deformation on Zenna_body
# ======================================
# Inserts Script SOP between bonegroup and null for mouth deformation
#
# exec(open(project.folder + '/setup_body_mouth.py').read())

print("\n" + "=" * 70)
print("SETTING UP MOUTH DEFORMATION ON ZENNA_BODY")
print("=" * 70)

# ============================================================================
# CONFIGURATION - Based on explore_body_mesh.py analysis
# ============================================================================

BODY_PATH = '/project1/luna_container/Luna/Zenna_body'
BLENDSHAPES_CHOP = '/project1/blend_shapes'

# Mouth region bounds from geometry analysis
MOUTH_Y_MIN = 1.428
MOUTH_Y_MAX = 1.543
MOUTH_Z_MIN = 0.098
MOUTH_Z_MAX = 0.159
LIP_BOUNDARY_Y = 1.486

# Deformation scales
JAW_SCALE = 0.02
LIP_UP_SCALE = 0.01
LIP_DOWN_SCALE = 0.01
SMILE_SCALE_Y = 0.008
SMILE_SCALE_X = 0.005
SMOOTHING = 0.7

# ============================================================================
# STEP 1: Get container and operators
# ============================================================================

print("\n[Step 1] Finding operators...")

container = op(BODY_PATH)
if container is None:
    print(f"ERROR: Container not found at {BODY_PATH}")
    raise SystemExit

mesh = container.op('mesh')
bonegroup = container.op('bonegroup')
null_out = container.op('null')

if not all([mesh, bonegroup, null_out]):
    print(f"ERROR: Required operators not found")
    print(f"  mesh: {mesh}")
    print(f"  bonegroup: {bonegroup}")
    print(f"  null: {null_out}")
    raise SystemExit

print(f"  Container: {container.path}")
print(f"  mesh: {mesh.path}")
print(f"  bonegroup: {bonegroup.path}")
print(f"  null: {null_out.path}")

# ============================================================================
# STEP 2: Clean up any existing setup
# ============================================================================

print("\n[Step 2] Cleaning up existing setup...")

old_script_sop = container.op('face_deform')
old_script_dat = container.op('mouth_deform_script')

if old_script_sop:
    # Reconnect null to bonegroup before deleting
    null_out.inputConnectors[0].connect(bonegroup)
    old_script_sop.destroy()
    print(f"  Deleted old face_deform")

if old_script_dat:
    old_script_dat.destroy()
    print(f"  Deleted old mouth_deform_script")

# ============================================================================
# STEP 3: Create Script SOP
# ============================================================================

print("\n[Step 3] Creating Script SOP...")

script_sop = container.create(scriptSOP, 'face_deform')
print(f"  Created: {script_sop.path}")

# Connect: bonegroup -> face_deform
script_sop.inputConnectors[0].connect(bonegroup)
print(f"  Connected: bonegroup -> face_deform")

# Reconnect: face_deform -> null
null_out.inputConnectors[0].connect(script_sop)
print(f"  Connected: face_deform -> null")

# Position in network
script_sop.nodeX = bonegroup.nodeX + 150
script_sop.nodeY = bonegroup.nodeY

# ============================================================================
# STEP 4: Create Script DAT with deformation code
# ============================================================================

print("\n[Step 4] Creating deformation script...")

SCRIPT_CONTENT = f'''# Mouth Deformation Script for Zenna_body
# Auto-generated by setup_body_mouth.py

import math

# Configuration
BLENDSHAPES_CHOP = '{BLENDSHAPES_CHOP}'
MOUTH_Y_MIN = {MOUTH_Y_MIN}
MOUTH_Y_MAX = {MOUTH_Y_MAX}
MOUTH_Z_MIN = {MOUTH_Z_MIN}
MOUTH_Z_MAX = {MOUTH_Z_MAX}
LIP_BOUNDARY_Y = {LIP_BOUNDARY_Y}

JAW_SCALE = {JAW_SCALE}
LIP_UP_SCALE = {LIP_UP_SCALE}
LIP_DOWN_SCALE = {LIP_DOWN_SCALE}
SMILE_SCALE_Y = {SMILE_SCALE_Y}
SMILE_SCALE_X = {SMILE_SCALE_X}
SMOOTHING = {SMOOTHING}


def onCook(scriptOP):
    """Called each frame to deform mouth vertices based on blendshapes."""

    # Copy input geometry FIRST - this is critical
    scriptOP.clear()
    if len(scriptOP.inputs) == 0 or scriptOP.inputs[0].numPoints == 0:
        return
    scriptOP.copy(scriptOP.inputs[0])

    # Initialize state using storage (persistent across cooks)
    if 'mouth_state' not in scriptOP.storage:
        scriptOP.storage['mouth_state'] = {{
            'initialized': False,
            'rest_positions': {{}},
            'mouth_vertices': [],
            'upper_lip_vertices': [],
            'lower_lip_vertices': [],
            'prev_deltas': {{}},
        }}

    state = scriptOP.storage['mouth_state']

    # Get blendshapes CHOP
    blend_chop = op(BLENDSHAPES_CHOP)
    if blend_chop is None:
        return

    # Initialize on first cook with geometry
    if not state['initialized']:
        # Store rest positions and identify mouth vertices
        for pt in scriptOP.points:
            pos = pt.P
            y, z = pos[1], pos[2]

            # Check if vertex is in mouth region
            if MOUTH_Y_MIN <= y <= MOUTH_Y_MAX and MOUTH_Z_MIN <= z <= MOUTH_Z_MAX:
                idx = pt.index
                state['mouth_vertices'].append(idx)
                state['rest_positions'][idx] = (pos[0], pos[1], pos[2])

                # Classify as upper or lower lip
                if y > LIP_BOUNDARY_Y:
                    state['upper_lip_vertices'].append(idx)
                else:
                    state['lower_lip_vertices'].append(idx)

        state['initialized'] = True
        print(f"[MouthDeform] Initialized: {{len(state['mouth_vertices'])}} mouth verts")
        print(f"  Upper lip: {{len(state['upper_lip_vertices'])}}")
        print(f"  Lower lip: {{len(state['lower_lip_vertices'])}}")

    # Get blendshape values with safe defaults
    def get_blend(name, default=0.0):
        try:
            chan = blend_chop[name]
            return chan.eval() if chan else default
        except:
            return default

    # Read blendshapes
    jaw_open = get_blend('jawOpen')
    mouth_upper_up_l = get_blend('mouthUpperUpLeft')
    mouth_upper_up_r = get_blend('mouthUpperUpRight')
    mouth_lower_down_l = get_blend('mouthLowerDownLeft')
    mouth_lower_down_r = get_blend('mouthLowerDownRight')
    mouth_smile_l = get_blend('mouthSmileLeft')
    mouth_smile_r = get_blend('mouthSmileRight')
    mouth_pucker = get_blend('mouthPucker')

    # Average left/right values
    mouth_upper_up = (mouth_upper_up_l + mouth_upper_up_r) / 2
    mouth_lower_down = (mouth_lower_down_l + mouth_lower_down_r) / 2
    mouth_smile = (mouth_smile_l + mouth_smile_r) / 2

    # Calculate center X of mouth for smile displacement
    if state['mouth_vertices']:
        mouth_center_x = sum(state['rest_positions'][i][0] for i in state['mouth_vertices']) / len(state['mouth_vertices'])
    else:
        mouth_center_x = 0.0

    # Apply deformation to mouth vertices
    for idx in state['mouth_vertices']:
        rest = state['rest_positions'][idx]
        rest_x, rest_y, rest_z = rest

        # Calculate delta
        delta_x = 0.0
        delta_y = 0.0
        delta_z = 0.0

        # Determine lip region (upper vs lower)
        is_upper = idx in state['upper_lip_vertices']
        is_lower = idx in state['lower_lip_vertices']

        # Y displacement from jaw opening and lip movements
        if is_lower:
            # Lower lip moves down with jaw and mouthLowerDown
            delta_y = -jaw_open * JAW_SCALE - mouth_lower_down * LIP_DOWN_SCALE
        elif is_upper:
            # Upper lip moves up with mouthUpperUp
            delta_y = mouth_upper_up * LIP_UP_SCALE

        # Smile: lift corners (vertices away from center X)
        x_dist_from_center = abs(rest_x - mouth_center_x)
        corner_factor = min(1.0, x_dist_from_center / 0.05)  # Normalize
        delta_y += mouth_smile * SMILE_SCALE_Y * corner_factor

        # Smile: spread corners outward (X)
        if rest_x > mouth_center_x:
            delta_x += mouth_smile * SMILE_SCALE_X * corner_factor
        else:
            delta_x -= mouth_smile * SMILE_SCALE_X * corner_factor

        # Pucker: move lips forward (Z)
        delta_z += mouth_pucker * 0.01

        # Apply smoothing
        prev = state['prev_deltas'].get(idx, (0, 0, 0))
        delta_x = prev[0] * SMOOTHING + delta_x * (1 - SMOOTHING)
        delta_y = prev[1] * SMOOTHING + delta_y * (1 - SMOOTHING)
        delta_z = prev[2] * SMOOTHING + delta_z * (1 - SMOOTHING)
        state['prev_deltas'][idx] = (delta_x, delta_y, delta_z)

        # Apply final position
        scriptOP.points[idx].P = (rest_x + delta_x, rest_y + delta_y, rest_z + delta_z)
'''

script_dat = container.create(textDAT, 'mouth_deform_script')
script_dat.text = SCRIPT_CONTENT
print(f"  Created: {script_dat.path}")
print(f"  Script length: {len(SCRIPT_CONTENT)} chars")

# Position DAT
script_dat.nodeX = script_sop.nodeX
script_dat.nodeY = script_sop.nodeY - 150

# ============================================================================
# STEP 5: Link Script DAT to Script SOP
# ============================================================================

print("\n[Step 5] Linking script to SOP...")

script_sop.par.callbacks = script_dat.path
print(f"  Set callbacks: {script_sop.par.callbacks.eval()}")

# ============================================================================
# STEP 6: Force cook and verify
# ============================================================================

print("\n[Step 6] Verifying setup...")

# Force cook to initialize
script_sop.cook(force=True)

# Check results
try:
    num_points = script_sop.numPoints
    print(f"  Script SOP has {num_points} points")

    if 'mouth_state' in script_sop.storage:
        state = script_sop.storage['mouth_state']
        print(f"  State initialized: {state.get('initialized', False)}")
        print(f"  Mouth vertices: {len(state.get('mouth_vertices', []))}")
        print(f"  Upper lip: {len(state.get('upper_lip_vertices', []))}")
        print(f"  Lower lip: {len(state.get('lower_lip_vertices', []))}")
    else:
        print(f"  State not yet initialized (will init on next cook)")
except Exception as e:
    print(f"  Error checking script: {e}")

# ============================================================================
# SUMMARY
# ============================================================================

print("\n" + "=" * 70)
print("SETUP COMPLETE")
print("=" * 70)
print(f"""
Network chain:
  mesh (importselectSOP)
    -> bonegroup (bonegroupSOP)
    -> face_deform (Script SOP) [NEW - mouth deformation]
    -> null (nullSOP)
    -> phong1 (render material)

The Script SOP applies blendshape-driven mouth deformation:
  - jawOpen -> lower lip/jaw moves down
  - mouthUpperUp -> upper lip moves up
  - mouthLowerDown -> lower lip moves down
  - mouthSmile -> corners lift and spread
  - mouthPucker -> lips move forward

To test:
  1. Make sure MediaPipe face tracking is running
  2. Open your mouth - jaw should open on model
  3. Smile - corners should lift

If not working, check:
  - Blendshapes CHOP at {BLENDSHAPES_CHOP}
  - Script SOP state: op('{BODY_PATH}/face_deform').storage['mouth_state']
""")
print("=" * 70 + "\n")
